# -*- coding: utf-8 -*-
"""Holograma.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q6qR5i4qdB_l8UzA6QlW5w6hOTgFThY9
"""

#!/usr/bin/env python3
"""
holograma_pi.py
Esqueleto de control principal para Raspberry Pi (Holograma).
Funcionalidad:
 - Reproducir logo de la universidad en bucle (idle)
 - Escuchar Arduino por Serial (PRESENCE)
 - Comunicar con Tablet por Bluetooth RFCOMM (UNLOCK_MENU / LOCK_MENU)
 - Reproducir videos seleccionados
 - Control relé para encender/apagar proyector según inactividad
 - Registro de estadísticas en SQLite
"""

import os
import sys
import time
import threading
import subprocess
import serial
import logging
import sqlite3
from datetime import datetime
from queue import Queue, Empty

# IMPORTA RPi.GPIO si se ejecuta en Raspberry Pi real
try:
    import RPi.GPIO as GPIO
except Exception as e:
    GPIO = None
    print("Advertencia: RPi.GPIO no disponible (no se ejecuta en Raspberry Pi).", e)

#PyBluez para RFCOMM server
try:
    import bluetooth
except Exception as e:
    bluetooth = None
    print("Advertencia: PyBluez no disponible. Bluetooth no funcionará hasta instalar pybluez.", e)


# --------------------------
# CONFIGURACIONES INICIALES
# --------------------------
SERIAL_PORT = '/dev/ttyUSB0'
SERIAL_BAUD = 9600 #Baudios

BT_PORT = 3                        # RFCOMM channel(Puerto Serial Virtual)
BT_SERVER_NAME = "HologramaPi"     # Nombre del servidor BT

VIDEO_DIR = "/home/pi/videos/"     # Directorio de videos
IDLE_VIDEO = os.path.join(VIDEO_DIR, "logo_girando.mp4") #Video de espera
ASSISTANT_VIDEO = os.path.join(VIDEO_DIR, "assistant_explainer.mp4") #Asistente virtual

# Mapa id -> Videos(Diccionario)
VIDEO_MAP = {
    "video01": os.path.join(VIDEO_DIR, "instalaciones.mp4"),
    "video02": os.path.join(VIDEO_DIR, "procesos.mp4"),
    "video03": os.path.join(VIDEO_DIR, "logros.mp4"),
    # ...
}

RELAY_GPIO_PIN = 18   # Pin GPIO que controla el relé que alimenta el proyector
PROJECTOR_RELAY_ACTIVE_HIGH = True  # True si 3.3V activa el relé -> USAR LEVEL SHIFTER PARA RELÉ

INACTIVITY_SHUTDOWN_SECONDS = 60 * 60  # 1 Hora

DB_PATH = "/home/pi/holograma/holograma_stats.db" #Base de datos

# -----------------------
# LOGGING
# -----------------------
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
log = logging.getLogger("holograma")

# -----------------------
# UTIL / DB
# -----------------------
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS events (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ts TEXT,
                    type TEXT,
                    detail TEXT
                )''')
    conn.commit()
    conn.close()

def log_event(event_type, detail=""):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    # Insertar hora local
    ts_local = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    c.execute("INSERT INTO events (ts, type, detail) VALUES (?, ?, ?)", (ts_local, event_type, detail))

    conn.commit()
    conn.close()
    log.info("Event logged: %s %s", event_type, detail)

# -----------------------
# REPRODUCTOR (VLC via cvlc)
# -----------------------
class VideoController:
    def __init__(self):
        self.proc = None
        self.lock = threading.Lock()
        self.current = None

    def play_loop(self, path):
        """Inicia cvlc en loop (bloqueante en su propio proceso)."""
        with self.lock:
            self.stop()
            log.info("Play loop: %s", path)
            # -q para evitar log verbose, --loop para loop
            self.proc = subprocess.Popen(["cvlc", "--no-video-title-show", "--loop", path],
                                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.current = ("loop", path)

    def play_once(self, path):
        with self.lock:
            self.stop()
            log.info("Play once: %s", path)
            self.proc = subprocess.Popen(["cvlc", "--no-video-title-show", "--play-and-exit", path],
                                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.current = ("once", path)
            return_code = self.proc.wait()
            log.info("Playback finished: %s (rc=%s)", path, return_code)
            self.current = None
            return return_code

    def stop(self):
        with self.lock:
            if self.proc and self.proc.poll() is None:
                try:
                    self.proc.terminate()
                    time.sleep(0.5)
                    if self.proc.poll() is None:
                        self.proc.kill()
                except Exception as e:
                    log.warning("Error stopping player: %s", e)
            self.proc = None
            self.current = None

# -----------------------
# RELAY control
# -----------------------
class RelayController:
    def __init__(self, pin, active_high=True):
        self.pin = pin
        self.active_high = active_high
        if GPIO:
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.pin, GPIO.OUT)
            self.off()

    def on(self):
        log.info("Relay on (pin %s)", self.pin)
        if GPIO:
            GPIO.output(self.pin, GPIO.HIGH if self.active_high else GPIO.LOW)

    def off(self):
        log.info("Relay off (pin %s)", self.pin)
        if GPIO:
            GPIO.output(self.pin, GPIO.LOW if self.active_high else GPIO.HIGH)


# -----------------------
# SERIAL Reader (Arduino)
# -----------------------
class SerialReader(threading.Thread):
    def __init__(self, port, baud, out_queue):
        super().__init__(daemon=True)
        self.port = port
        self.baud = baud
        self.out_queue = out_queue
        self.alive = True
        self.ser = None

    def run(self):
        while self.alive:
            try:
                if self.ser is None:
                    log.info("Open serial port %s @ %d", self.port, self.baud)
                    self.ser = serial.Serial(self.port, self.baud, timeout=1)
                    time.sleep(2)
                line = self.ser.readline().decode('utf-8', errors='ignore').strip()
                if line:
                    log.info("Serial recv: %s", line)
                    self.out_queue.put(("serial", line))
            except serial.SerialException as e:
                log.error("Serial exception: %s", e)
                self.ser = None
                time.sleep(2)
            except Exception as e:
                log.exception("Serial reader error: %s", e)
                time.sleep(1)

    def stop(self):
        self.alive = False
        if self.ser:
            try:
                self.ser.close()
            except:
                pass

# -----------------------
# Bluetooth RFCOMM Server (tablet)
# -----------------------
class BluetoothServer(threading.Thread):
    def __init__(self, out_queue):
        super().__init__(daemon=True)
        self.out_queue = out_queue
        self.server_sock = None
        self.client_sock = None
        self.alive = True

    def run(self):
        if bluetooth is None:
            log.warning("Bluetooth no inicializado (pybluez requerido).")
            return
        try:
            self.server_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
            self.server_sock.bind(("", BT_PORT))
            self.server_sock.listen(1)
            log.info("Bluetooth RFCOMM listening on port %s", BT_PORT)
            while self.alive:
                log.info("Esperando conexión Bluetooth de tablet...")
                client_sock, address = self.server_sock.accept()
                self.client_sock = client_sock
                log.info("Tablet conectada: %s", address)
                self.out_queue.put(("bt_connect", address))
                try:
                    while self.alive:
                        data = client_sock.recv(1024)
                        if not data:
                            break
                        text = data.decode('utf-8', errors='ignore').strip()
                        log.info("BT recv: %s", text)
                        self.out_queue.put(("bt", text))
                except Exception as e:
                    log.warning("Bluetooth client error: %s", e)
                finally:
                    try:
                        client_sock.close()
                    except:
                        pass
                    self.client_sock = None
                    log.info("Tablet desconectada")
                    self.out_queue.put(("bt_disconnect", address))
        except Exception as e:
            log.exception("Bluetooth server error: %s", e)
        finally:
            if self.server_sock:
                try:
                    self.server_sock.close()
                except:
                    pass

    def send(self, text):
        if self.client_sock:
            try:
                self.client_sock.send((text + "\n").encode('utf-8'))
                log.info("BT send: %s", text)
            except Exception as e:
                log.warning("Error enviando por BT: %s", e)
        else:
            log.debug("No client BT conectado para enviar: %s", text)

    def stop(self):
        self.alive = False
        if self.client_sock:
            try:
                self.client_sock.close()
            except:
                pass
        if self.server_sock:
            try:
                self.server_sock.close()
            except:
                pass

# -----------------------
# STATE MACHINE
# -----------------------
class HoloController:
    def __init__(self):
        self.queue = Queue()
        self.serial_thread = SerialReader(SERIAL_PORT, SERIAL_BAUD, self.queue)
        self.bt_server = BluetoothServer(self.queue)
        self.video = VideoController()
        self.relay = RelayController(RELAY_GPIO_PIN, active_high=PROJECTOR_RELAY_ACTIVE_HIGH)
        self.state = "IDLE"
        self.last_interaction_ts = time.time()
        self.idle_thread = None
        self.running = True
        init_db()

    def start(self):
        log.info("Starting HoloController")
        self.serial_thread.start()
        self.bt_server.start()
        # Start idle video loop
        self._enter_idle()
        # main loop
        try:
            while self.running:
                try:
                    typ, data = self.queue.get(timeout=0.5)
                except Empty:
                    # check inactivity
                    self._check_inactivity()
                    continue

                if typ == "serial":
                    self._handle_serial(data)
                elif typ == "bt":
                    self._handle_bt_msg(data)
                elif typ == "bt_connect":
                    log.info("Tablet connected %s", data)
                elif typ == "bt_disconnect":
                    log.info("Tablet disconnected %s", data)
                else:
                    log.debug("Queue item: %s %s", typ, data)
        except KeyboardInterrupt:
            log.info("Keyboard interrupt, stopping")
        finally:
            self.stop()

    def stop(self):
        log.info("Stopping HoloController")
        self.running = False
        try:
            self.serial_thread.stop()
            self.bt_server.stop()
        except:
            pass
        self.video.stop()
        # leave projector powered? optional: turn off
        self.relay.off()

    # -----------------------
    # Event handlers
    # -----------------------
    def _handle_serial(self, line):
        if line.upper().startswith("PRESENCE") or "MOVIMIENTO" in line.upper():
            log.info("Presence detected")
            log_event("presence_detected")
            self.last_interaction_ts = time.time()
            if self.state == "IDLE":
                self._enter_detection()
        elif line.upper().startswith("ABSENCE"):
            log.info("Absence reported")
            # optional: treat as request to go idle after a tiny delay
            if self.state != "IDLE":
                # set a small timeout to check
                self.last_interaction_ts = time.time() - (INACTIVITY_SHUTDOWN_SECONDS - 10)

    def _handle_bt_msg(self, text):
        # messages from tablet
        if text.startswith("PLAY:"):
            vid = text.split(":",1)[1].strip()
            log.info("Play request: %s", vid)
            self.last_interaction_ts = time.time()
            log_event("video_request", vid)
            # Play if exists
            if vid in VIDEO_MAP:
                self._play_video(VIDEO_MAP[vid], vid)
            else:
                log.warning("Video id not found: %s", vid)
        elif text.startswith("VOLUME:"):
            # optional, to implement
            vol = int(text.split(":",1)[1])
            self._set_volume(vol)
        elif text == "CANCEL":
            log.info("Cancel request from tablet")
            self._stop_playback_and_return_menu()
        elif text == "PING":
            # keepalive
            pass
        else:
            log.info("Unhandled BT message: %s", text)

    # -----------------------
    # State transitions
    # -----------------------
    def _enter_idle(self):
        log.info("Enter IDLE state")
        self.state = "IDLE"
        # ensure projector is on (optional: could be off)
        self.relay.on()
        # Lock tablet menu if connected
        self.bt_server.send("LOCK_MENU")
        # Play idle loop
        self.video.play_loop(IDLE_VIDEO)

    def _enter_detection(self):
        log.info("Enter DETECTION state")
        self.state = "DETECTION"
        # Stop idle
        self.video.stop()
        # Ensure projector on
        self.relay.on()
        # Play assistant explainer once (or loop short)
        # Notify tablet to unlock
        self.bt_server.send("UNLOCK_MENU")
        self.bt_server.send("ASSISTANT:START")
        # Play assistant video once (non-blocking: run in thread)
        t = threading.Thread(target=self._play_assistant_then_menu, daemon=True)
        t.start()

    def _play_assistant_then_menu(self):
        log.info("Playing assistant video")
        self.video.play_once(ASSISTANT_VIDEO)
        # After assistant ends, we can keep assistant overlay or return to menu state
        # Tablet should already be unlocked; keep the assistant background or send instruction
        self.bt_server.send("ASSISTANT:STOP")
        # Keep state as detection; wait for PLAY command from tablet

    def _play_video(self, path, vid_id=None):
        log.info("Play the selected video: %s", path)
        self.state = "PLAYING"
        # Stop any assistant or idle
        self.video.stop()
        # Start playing (blocking until finishes) but in separate thread to not block main loop:
        def play_and_finish():
            self.relay.on()  # ensure projector on
            log_event("play_start", vid_id or path)
            self.video.play_once(path)
            log_event("play_end", vid_id or path)
            # After finishing playback, return to detection (menu) if still presence, else IDLE
            # If last interaction within inactivity timeframe -> go to DETECTION; else IDLE
            if time.time() - self.last_interaction_ts < 60:
                log.info("Returning to DETECTION state after playback")
                self._enter_detection()
            else:
                log.info("No recent interaction, returning to IDLE")
                self._enter_idle()
        t = threading.Thread(target=play_and_finish, daemon=True)
        t.start()

    def _stop_playback_and_return_menu(self):
        self.video.stop()
        self._enter_detection()

    def _set_volume(self, percent):
        # Implement control via amixer or pactl
        vol = max(0, min(100, percent))
        cmd = f"amixer set PCM {vol}%"
        log.info("Setting volume: %s", cmd)
        subprocess.call(cmd, shell=True)

    def _check_inactivity(self):
        # Called often; shutdown if overall inactivity timeout exceeded
        if self.state in ("IDLE",):
            return
        elapsed = time.time() - self.last_interaction_ts
        if elapsed >= INACTIVITY_SHUTDOWN_SECONDS:
            log.info("Inactivity timeout reached. Going to safe shutdown.")
            log_event("inactivity_shutdown")
            # lock tablet, stop playback, turn off projector and shutdown
            self.bt_server.send("LOCK_MENU")
            self.video.stop()
            # Turn off projector via relay (ensure projector safe)
            self.relay.off()
            # Wait a bit and shutdown Pi
            time.sleep(2)
            log.info("Shutdown now")
            subprocess.call(["sudo", "shutdown", "-h", "now"])

# -----------------------
# MAIN
# -----------------------
def main():
    if GPIO is None:
        log.warning("RPi.GPIO no disponible — el control físico de relé será ignorado en ejecución local.")
    c = HoloController()
    c.start()

if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""
holograma_pi.py
Esqueleto de control principal para Raspberry Pi (Holograma).
Funcionalidad:
 - Reproducir logo de la universidad en bucle (idle)
 - Escuchar Arduino por Serial (PRESENCE)
 - Comunicar con Tablet por Bluetooth RFCOMM (UNLOCK_MENU / LOCK_MENU)
 - Reproducir videos seleccionados
 - Control relé para encender/apagar proyector según inactividad
 - Registro de estadísticas en SQLite
"""

import os
import sys
import time
import threading
import subprocess
import serial
import logging
import sqlite3
from datetime import datetime
from queue import Queue, Empty

# IMPORTA RPi.GPIO si se ejecuta en Raspberry Pi real
try:
    import RPi.GPIO as GPIO
except Exception as e:
    GPIO = None
    print("Advertencia: RPi.GPIO no disponible (no se ejecuta en Raspberry Pi).", e)

#PyBluez para RFCOMM server
try:
    import bluetooth
except Exception as e:
    bluetooth = None
    print("Advertencia: PyBluez no disponible. Bluetooth no funcionará hasta instalar pybluez.", e)


# --------------------------
# CONFIGURACIONES INICIALES
# --------------------------
SERIAL_PORT = '/dev/ttyUSB0'       # Ajustar según donde va ir conectado el Arduino
SERIAL_BAUD = 9600 #Baudios

BT_PORT = 3                        # RFCOMM channel(Puerto Serial Virtual)
BT_SERVER_NAME = "HologramaPi"     # Nombre del servidor BT

VIDEO_DIR = "/home/pi/videos/"     # Directorio de videos
IDLE_VIDEO = os.path.join(VIDEO_DIR, "logo_girando.mp4") #Video de espera
ASSISTANT_VIDEO = os.path.join(VIDEO_DIR, "assistant_explainer.mp4") #Asistente virtual

# Mapa id -> Videos(Diccionario)
VIDEO_MAP = {
    "video01": os.path.join(VIDEO_DIR, "instalaciones.mp4"),
    "video02": os.path.join(VIDEO_DIR, "procesos.mp4"),
    "video03": os.path.join(VIDEO_DIR, "logros.mp4"),
    # ...
}

RELAY_GPIO_PIN = 18   # Pin GPIO que controla el relé que alimenta el proyector
PROJECTOR_RELAY_ACTIVE_HIGH = True  # True si 3.3V activa el relé -> USAR LEVEL SHIFTER PARA RELÉ

INACTIVITY_SHUTDOWN_SECONDS = 60 * 60  # 1 Hora

DB_PATH = "/home/pi/holograma/holograma_stats.db" #Base de datos

# -----------------------
# LOGGING
# -----------------------
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
log = logging.getLogger("holograma")

# -----------------------
# UTIL / DB
# -----------------------
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS events (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ts TEXT,
                    type TEXT,
                    detail TEXT
                )''')
    conn.commit()
    conn.close()

def log_event(event_type, detail=""):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    # Insertar hora local
    ts_local = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    c.execute("INSERT INTO events (ts, type, detail) VALUES (?, ?, ?)", (ts_local, event_type, detail))

    conn.commit()
    conn.close()
    log.info("Event logged: %s %s", event_type, detail)

# -----------------------
# REPRODUCTOR (VLC via cvlc)
# -----------------------
class VideoController:
    def __init__(self):
        self.proc = None
        self.lock = threading.Lock()
        self.current = None

    def play_loop(self, path):
        """Inicia cvlc en loop (bloqueante en su propio proceso)."""
        with self.lock:
            self.stop()
            log.info("Play loop: %s", path)
            # -q para evitar log verbose, --loop para loop
            self.proc = subprocess.Popen(["cvlc", "--no-video-title-show", "--loop", path],
                                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.current = ("loop", path)

    def play_once(self, path):
        with self.lock:
            self.stop()
            log.info("Play once: %s", path)
            self.proc = subprocess.Popen(["cvlc", "--no-video-title-show", "--play-and-exit", path],
                                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.current = ("once", path)
            return_code = self.proc.wait()
            log.info("Playback finished: %s (rc=%s)", path, return_code)
            self.current = None
            return return_code

    def stop(self):
        with self.lock:
            if self.proc and self.proc.poll() is None:
                try:
                    self.proc.terminate()
                    time.sleep(0.5)
                    if self.proc.poll() is None:
                        self.proc.kill()
                except Exception as e:
                    log.warning("Error stopping player: %s", e)
            self.proc = None
            self.current = None

# -----------------------
# RELAY control
# -----------------------
class RelayController:
    def __init__(self, pin, active_high=True):
        self.pin = pin
        self.active_high = active_high
        if GPIO:
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.pin, GPIO.OUT)
            self.off()

    def on(self):
        log.info("Relay on (pin %s)", self.pin)
        if GPIO:
            GPIO.output(self.pin, GPIO.HIGH if self.active_high else GPIO.LOW)

    def off(self):
        log.info("Relay off (pin %s)", self.pin)
        if GPIO:
            GPIO.output(self.pin, GPIO.LOW if self.active_high else GPIO.HIGH)


# -----------------------
# SERIAL Reader (Arduino)
# -----------------------
class SerialReader(threading.Thread):
    def __init__(self, port, baud, out_queue):
        super().__init__(daemon=True)
        self.port = port
        self.baud = baud
        self.out_queue = out_queue
        self.alive = True
        self.ser = None

    def run(self):
        while self.alive:
            try:
                if self.ser is None:
                    log.info("Open serial port %s @ %d", self.port, self.baud)
                    self.ser = serial.Serial(self.port, self.baud, timeout=1)
                    time.sleep(2)
                line = self.ser.readline().decode('utf-8', errors='ignore').strip()
                if line:
                    log.info("Serial recv: %s", line)
                    self.out_queue.put(("serial", line))
            except serial.SerialException as e:
                log.error("Serial exception: %s", e)
                self.ser = None
                time.sleep(2)
            except Exception as e:
                log.exception("Serial reader error: %s", e)
                time.sleep(1)

    def stop(self):
        self.alive = False
        if self.ser:
            try:
                self.ser.close()
            except:
                pass

# -----------------------
# Bluetooth RFCOMM Server (tablet)
# -----------------------
class BluetoothServer(threading.Thread):
    def __init__(self, out_queue):
        super().__init__(daemon=True)
        self.out_queue = out_queue
        self.server_sock = None
        self.client_sock = None
        self.alive = True

    def run(self):
        if bluetooth is None:
            log.warning("Bluetooth no inicializado (pybluez requerido).")
            return
        try:
            self.server_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
            self.server_sock.bind(("", BT_PORT))
            self.server_sock.listen(1)
            log.info("Bluetooth RFCOMM listening on port %s", BT_PORT)
            while self.alive:
                log.info("Esperando conexión Bluetooth de tablet...")
                client_sock, address = self.server_sock.accept()
                self.client_sock = client_sock
                log.info("Tablet conectada: %s", address)
                self.out_queue.put(("bt_connect", address))
                try:
                    while self.alive:
                        data = client_sock.recv(1024)
                        if not data:
                            break
                        text = data.decode('utf-8', errors='ignore').strip()
                        log.info("BT recv: %s", text)
                        self.out_queue.put(("bt", text))
                except Exception as e:
                    log.warning("Bluetooth client error: %s", e)
                finally:
                    try:
                        client_sock.close()
                    except:
                        pass
                    self.client_sock = None
                    log.info("Tablet desconectada")
                    self.out_queue.put(("bt_disconnect", address))
        except Exception as e:
            log.exception("Bluetooth server error: %s", e)
        finally:
            if self.server_sock:
                try:
                    self.server_sock.close()
                except:
                    pass

    def send(self, text):
        if self.client_sock:
            try:
                self.client_sock.send((text + "\n").encode('utf-8'))
                log.info("BT send: %s", text)
            except Exception as e:
                log.warning("Error enviando por BT: %s", e)
        else:
            log.debug("No client BT conectado para enviar: %s", text)

    def stop(self):
        self.alive = False
        if self.client_sock:
            try:
                self.client_sock.close()
            except:
                pass
        if self.server_sock:
            try:
                self.server_sock.close()
            except:
                pass

# -----------------------
# STATE MACHINE
# -----------------------
class HoloController:
    def __init__(self):
        self.queue = Queue()
        self.serial_thread = SerialReader(SERIAL_PORT, SERIAL_BAUD, self.queue)
        self.bt_server = BluetoothServer(self.queue)
        self.video = VideoController()
        self.relay = RelayController(RELAY_GPIO_PIN, active_high=PROJECTOR_RELAY_ACTIVE_HIGH)
        self.state = "IDLE"
        self.last_interaction_ts = time.time()
        self.idle_thread = None
        self.running = True
        init_db()

    def start(self):
        log.info("Starting HoloController")
        self.serial_thread.start()
        self.bt_server.start()
        # Start idle video loop
        self._enter_idle()
        # main loop
        try:
            while self.running:
                try:
                    typ, data = self.queue.get(timeout=0.5)
                except Empty:
                    # check inactivity
                    self._check_inactivity()
                    continue

                if typ == "serial":
                    self._handle_serial(data)
                elif typ == "bt":
                    self._handle_bt_msg(data)
                elif typ == "bt_connect":
                    log.info("Tablet connected %s", data)
                elif typ == "bt_disconnect":
                    log.info("Tablet disconnected %s", data)
                else:
                    log.debug("Queue item: %s %s", typ, data)
        except KeyboardInterrupt:
            log.info("Keyboard interrupt, stopping")
        finally:
            self.stop()

    def stop(self):
        log.info("Stopping HoloController")
        self.running = False
        try:
            self.serial_thread.stop()
            self.bt_server.stop()
        except:
            pass
        self.video.stop()
        # leave projector powered? optional: turn off
        self.relay.off()

    # -----------------------
    # Event handlers
    # -----------------------
    def _handle_serial(self, line):
        if line.upper().startswith("PRESENCE") or "MOVIMIENTO" in line.upper():
            log.info("Presence detected")
            log_event("presence_detected")
            self.last_interaction_ts = time.time()
            if self.state == "IDLE":
                self._enter_detection()
        elif line.upper().startswith("ABSENCE"):
                log.info("Absence reported")
                log_event("absence_detected")

                # Reinicia el temporizador de interacción al momento actual
                # (marcamos el inicio de la inactividad real)
                self.last_interaction_ts = time.time()

                # Si no estamos ya en IDLE, cambiamos al estado IDLE
                if self.state != "IDLE":
                    log.info("Switching to IDLE state after absence")
                    self._enter_idle()


    def _handle_bt_msg(self, text):
        # messages from tablet
        if text.startswith("PLAY:"):
            vid = text.split(":",1)[1].strip()
            log.info("Play request: %s", vid)
            self.last_interaction_ts = time.time()
            log_event("video_request", vid)
            # Play if exists
            if vid in VIDEO_MAP:
                self._play_video(VIDEO_MAP[vid], vid)
            else:
                log.warning("Video id not found: %s", vid)
        elif text.startswith("VOLUME:"):
            # optional, to implement
            vol = int(text.split(":",1)[1])
            self._set_volume(vol)
        elif text == "CANCEL":
            log.info("Cancel request from tablet")
            self._stop_playback_and_return_menu()
        elif text == "PING":
            # keepalive
            pass
        else:
            log.info("Unhandled BT message: %s", text)

    # -----------------------
    # State transitions
    # -----------------------
    def _enter_idle(self):
        log.info("Enter IDLE state")
        self.state = "IDLE"
        # ensure projector is on (optional: could be off)
        self.relay.on()
        # Lock tablet menu if connected
        self.bt_server.send("LOCK_MENU")
        # Play idle loop
        self.video.play_loop(IDLE_VIDEO)

    def _enter_detection(self):
        log.info("Enter DETECTION state")
        self.state = "DETECTION"
        # Stop idle
        self.video.stop()
        # Ensure projector on
        self.relay.on()
        # Play assistant explainer once (or loop short)
        # Notify tablet to unlock
        self.bt_server.send("UNLOCK_MENU")
        self.bt_server.send("ASSISTANT:START")
        # Play assistant video once (non-blocking: run in thread)
        t = threading.Thread(target=self._play_assistant_then_menu, daemon=True)
        t.start()

    def _play_assistant_then_menu(self):
        log.info("Playing assistant video")
        self.video.play_once(ASSISTANT_VIDEO)
        # After assistant ends, we can keep assistant overlay or return to menu state
        # Tablet should already be unlocked; keep the assistant background or send instruction
        self.bt_server.send("ASSISTANT:STOP")
        # Keep state as detection; wait for PLAY command from tablet

    def _play_video(self, path, vid_id=None):
        log.info("Play the selected video: %s", path)
        self.state = "PLAYING"
        # Stop any assistant or idle
        self.video.stop()
        # Start playing (blocking until finishes) but in separate thread to not block main loop:
        def play_and_finish():
            self.relay.on()  # ensure projector on
            log_event("play_start", vid_id or path)
            self.video.play_once(path)
            log_event("play_end", vid_id or path)
            # After finishing playback, return to detection (menu) if still presence, else IDLE
            # If last interaction within inactivity timeframe -> go to DETECTION; else IDLE
            if time.time() - self.last_interaction_ts < 60:
                log.info("Returning to DETECTION state after playback")
                self._enter_detection()
            else:
                log.info("No recent interaction, returning to IDLE")
                self._enter_idle()
        t = threading.Thread(target=play_and_finish, daemon=True)
        t.start()

    def _stop_playback_and_return_menu(self):
        self.video.stop()
        self._enter_detection()

    def _set_volume(self, percent):
        # Implement control via amixer or pactl
        vol = max(0, min(100, percent))
        cmd = f"amixer set PCM {vol}%"
        log.info("Setting volume: %s", cmd)
        subprocess.call(cmd, shell=True)

    def _check_inactivity(self):
        # Called often; shutdown if overall inactivity timeout exceeded
        if self.state in ("IDLE",):
            return
        elapsed = time.time() - self.last_interaction_ts
        if elapsed >= INACTIVITY_SHUTDOWN_SECONDS:
            log.info("Inactivity timeout reached. Going to safe shutdown.")
            log_event("inactivity_shutdown")
            # lock tablet, stop playback, turn off projector and shutdown
            self.bt_server.send("LOCK_MENU")
            self.video.stop()
            # Turn off projector via relay (ensure projector safe)
            self.relay.off()
            # Wait a bit and shutdown Pi
            time.sleep(2)
            log.info("Shutdown now")
            subprocess.call(["sudo", "shutdown", "-h", "now"])

# -----------------------
# MAIN
# -----------------------
def main():
    if GPIO is None:
        log.warning("RPi.GPIO no disponible — el control físico de relé será ignorado en ejecución local.")
    c = HoloController()
    c.start()

if __name__ == "__main__":
    main()

import subprocess, time

proc = subprocess.Popen(["sleep", "3"])  # simula un proceso que tarda 3 segundos

while True:
    estado = proc.poll()
    if estado is None:
        print("⏳ Aún está corriendo...")
        time.sleep(1)
    else:
        print("✅ Proceso terminado. Código:", estado)
        break